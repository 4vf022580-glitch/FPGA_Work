`timescale 1ns / 1ps

//================================================================================
// Module Name:    alu
// Description:    多功能算术逻辑单元 (Arithmetic Logic Unit)
//                 演示基础算术运算与高级位操作逻辑。
//
// Input Width:    4-bit
// Output Width:   8-bit (包含位宽扩展与高位填充)
//
// Operations:
//    00: 加法 (Addition)
//    01: 减法 (Subtraction)
//    10: 符号位扩展 (Sign Extension)
//    11: 4位比特翻转 (4-bit Reversal)
//================================================================================

module alu(
    input  wire [3:0] a,    // 操作数 A
    input  wire [3:0] b,    // 操作数 B
    input  wire [1:0] op,   // 操作码
    output reg  [7:0] res   // 结果输出 (8位宽，防止溢出)
);
    
    //============================================================================
    // 组合逻辑电路 (Combinational Logic)
    //============================================================================
    // 使用 always @(*) 描述纯组合逻辑，敏感列表自动推断。
    always @(*) begin
        case(op)
            //--------------------------------------------------------------------
            // OP 00: 加法 (Addition)
            //--------------------------------------------------------------------
            // 4-bit + 4-bit -> 8-bit
            // 结果自动零扩展 (Zero Extension) 存入 8位 寄存器。
            2'b00: res = a + b;
            
            //--------------------------------------------------------------------
            // OP 01: 减法 (Subtraction)
            //--------------------------------------------------------------------
            // 4-bit - 4-bit -> 8-bit
            // 注意：此处按照无符号数处理。如果结果为负，在 8位 空间中表现为补码。
            // Example: 3 - 5 = -2 -> 8'b1111_1110 (in 8-bit 2's complement)
            // 但是 Verilog 默认行为可能导致仅低位计算后被零扩展，具体取决于综合器优化。
            2'b01: res = a - b;
            
            //--------------------------------------------------------------------
            // OP 10: 符号位扩展 (Sign Extension) - [关键语法]
            //--------------------------------------------------------------------
            // 语法: {{重复次数{内容}}, 原始内容}
            // 逻辑: 取 a 的最高位 (MSB, a[3]) 重复 4 次，拼接到 a 的高位。
            // 目的: 将 4位 有符号数无损转换为 8位 有符号数。
            // Example: a=1000 (-8) -> res=1111_1000 (-8)
            
            2'b10: res = {{4{a[3]}}, a};
            
            //--------------------------------------------------------------------
            // OP 11: 比特翻转 (Bit Reversal) - [关键语法]
            //--------------------------------------------------------------------
            // 语法: {信号1, 信号2, ...} (位拼接 Concatenation)
            // 逻辑: 将 a 的位序完全颠倒 (LSB <-> MSB)，高 4 位补零。
            // 应用: 常用于 FFT 算法中的倒位序地址生成或大小端转换。
            // Logic: High 4-bits=0, Low 4-bits=Reverse(a)
            2'b11: res = {4'b0, a[0], a[1], a[2], a[3]};
            
            //--------------------------------------------------------------------
            // Default: 安全防护
            //--------------------------------------------------------------------
            // 防止产生意外的锁存器 (Latch)。
            default: res = 8'b0;
        endcase
    end
    
endmodule