`timescale 1ns / 1ps

//================================================================================
// Module Name:    tb_alu_reg
// Description:    ALU_REG 模块仿真测试平台 (Testbench)
//                 验证带寄存器输出的 ALU 模块的功能正确性与时序特性。
//
// Test Strategy:  1. 全局复位测试 (Global Reset Verification).
//                 2. 算术逻辑功能遍历 (ADD/SUB/AND/OR).
//                 3. 流水线时序验证 (Pipeline Latency Check): 验证输出相对于输入的时钟滞后特性。
//================================================================================

module tb_alu_reg(); // Testbench 为顶层仿真环境，无物理端口定义

    //----------------------------------------------------------------------------
    // 1. 信号定义 (Signal Definitions)
    //----------------------------------------------------------------------------
    // 激励信号 (Stimulus Signals): 用于驱动 DUT 输入，必须定义为 reg 类型以保持状态
    reg        clk;
    reg        rst;
    reg  [3:0] a;
    reg  [3:0] b;
    reg  [1:0] op;      // 操作码: 00=ADD, 01=SUB, 10=NOT, 11=AND

    // 观测信号 (Observation Signals): 连接 DUT 输出，实时监测逻辑结果
    wire [3:0] out;

    //----------------------------------------------------------------------------
    // 2. 待测设备实例化 (DUT Instantiation)
    //----------------------------------------------------------------------------
    // 将测试平台的内部信号映射到 ALU_REG 模块的端口
    alu_reg u_dut (
        .clk ( clk ),
        .rst ( rst ),
        .a   ( a   ),
        .b   ( b   ),
        .op  ( op  ),
        .out ( out )
    );

    //----------------------------------------------------------------------------
    // 3. 时钟生成 (Clock Generation)
    //----------------------------------------------------------------------------
    // 产生 100MHz 系统时钟 (Period = 10ns)
    // 用于驱动 DUT 的时序逻辑 (DFF)
    initial begin
        clk = 0;
        // 使用 forever 循环产生连续振荡信号
        forever begin
            #5 clk = ~clk;   // 半周期 5ns -> 全周期 10ns (100MHz)
        end
    end

    //----------------------------------------------------------------------------
    // 4. 主测试激励流程 (Main Stimulus Process)
    //----------------------------------------------------------------------------
    initial begin
        //========================================================================
        // Phase 1: 系统初始化与复位 (System Initialization & Reset)
        //========================================================================
        // 上电初始状态：断言复位 (Assert Reset)，所有输入信号置零
        rst = 1; 
        a   = 0;
        b   = 0;
        op  = 0;
        
        // 保持复位状态 20ns (2个时钟周期)，确保 D触发器进入已知状态 (Known State)
        #20;      
        
        rst = 0;  // 释放复位 (De-assert Reset)，系统开始正常工作

        //========================================================================
        // Phase 2: 加法功能验证 (ADD Verification)
        //========================================================================
        // 等待 10ns (1个时钟周期)，对齐时钟沿，模拟真实输入时序
        #10;      
        
        // Test Case 1: 2 + 3 = 5
        a  = 4'd2;
        b  = 4'd3;
        op = 2'b00; // Opcode: ADD
        
        // [时序行为说明]
        // 此时组合逻辑已计算出结果，但由于输出级存在寄存器 (DFF)，
        // 输出 'out' 不会立即更新，需等待下一个时钟上升沿 (Positive Edge) 采样。

        //========================================================================
        // Phase 3: 减法功能验证 (SUB Verification)
        //========================================================================
        // Test Case 2: 5 - 1 = 4
        // 维持上一状态 20ns (2个时钟周期)，确保有足够的建立时间 (Setup Time) 并观察输出稳定
        #20;
        a  = 5; // Input A
        b  = 1; // Input B
        op = 2'b01;   // Opcode: SUB

        //========================================================================
        // Phase 4: 输出保持特性验证 (Output Hold Verification)
        //========================================================================
        // 保持输入不变，验证 D触发器的锁存特性 (Latching Behavior)
        // 预期行为：输出应保持稳定，无亚稳态或毛刺
        #20;

        //========================================================================
        // Phase 5: 仿真结束 (End of Simulation)
        //========================================================================
        #20;
        $finish;  // 终止仿真进程并退出
    end

endmodule